generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email     String   @unique
  password  String?
  fullName  String?  @map("name")
  avatarUrl String?  @map("avatar_url")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  ownedGroups     Group[]        @relation("GroupOwner")
  memberships     GroupMember[]
  paidExpenses    Expense[]
  expenseSplits   ExpenseSplit[]
  settlementsFrom Settlement[]   @relation("SettlementFrom")
  settlementsTo   Settlement[]   @relation("SettlementTo")
  resetTokens       PasswordResetToken[]
  pushSubscriptions PushSubscription[]

  @@map("users")
}

model Group {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  ownerId     String   @map("owner_id") @db.Uuid
  name        String
  description String?
  currency    String   @default("USD")
  status      String   @default("active") @db.VarChar(20)
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  owner       User          @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members     GroupMember[]
  expenses    Expense[]
  settlements Settlement[]

  @@map("groups")
}

model GroupMember {
  groupId  String   @map("group_id") @db.Uuid
  memberId String   @map("member_id") @db.Uuid
  role     String   @default("member")
  joinedAt DateTime @default(now()) @map("joined_at") @db.Timestamptz(6)

  group  Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  member User  @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@id([groupId, memberId])
  @@index([memberId])
  @@map("group_members")
}

model Expense {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  groupId     String   @map("group_id") @db.Uuid
  payerId     String?  @map("payer_id") @db.Uuid
  description String
  amount      Decimal  @db.Decimal(12, 2)
  category    String?  @db.VarChar(50)
  splitType   String   @default("equal") @map("split_type") @db.VarChar(20)
  expenseDate DateTime @map("expense_date") @db.Date
  notes           String?
  receiptUrl      String?  @map("receipt_url")
  isRecurring     Boolean  @default(false) @map("is_recurring")
  recurrenceRule  String?  @map("recurrence_rule") @db.VarChar(50)
  nextOccurrence  DateTime? @map("next_occurrence") @db.Timestamptz(6)
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  group  Group          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  payer  User?          @relation(fields: [payerId], references: [id], onDelete: SetNull)
  splits ExpenseSplit[]

  @@index([groupId, createdAt])
  @@index([payerId])
  @@map("expenses")
}

model ExpenseSplit {
  id        String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  expenseId String  @map("expense_id") @db.Uuid
  memberId  String  @map("member_id") @db.Uuid
  share     Decimal @db.Decimal(12, 2)

  expense Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  member  User    @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([expenseId])
  @@index([memberId])
  @@map("expense_splits")
}

model Settlement {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  groupId        String   @map("group_id") @db.Uuid
  fromMember     String   @map("from_member") @db.Uuid
  toMember       String   @map("to_member") @db.Uuid
  amount         Decimal  @db.Decimal(12, 2)
  settlementDate DateTime @map("settlement_date") @db.Date
  notes          String?
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  from  User  @relation("SettlementFrom", fields: [fromMember], references: [id], onDelete: Cascade)
  to    User  @relation("SettlementTo", fields: [toMember], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@index([fromMember])
  @@index([toMember])
  @@map("settlements")
}

model PasswordResetToken {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  token     String    @unique
  expiresAt DateTime  @map("expires_at") @db.Timestamptz(6)
  usedAt    DateTime? @map("used_at") @db.Timestamptz(6)
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model PushSubscription {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  endpoint  String
  p256dh    String
  auth      String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId])
  @@map("push_subscriptions")
}
